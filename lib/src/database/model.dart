import 'dart:convert';

import 'package:equatable/equatable.dart';
import 'package:objectbox/objectbox.dart';
import 'package:tinode/src/models/server-messages.dart';

// ignore_for_file: public_member_api_docs

@Entity()
class LocalTopic {
  int id; // 1 * 1.000.000

  String name;

  @Backlink('localTopic')
  final messages = ToMany<DataMessage>();

  LocalTopic(this.name, {this.id = 0});

}


@Entity()
class DataMessage extends Equatable {
  final localTopic = ToOne<LocalTopic>();

  @Id(assignable: true)
  int id; // 10.000.000 + seq =
  
  @Unique()
  String? combinedId;

  /// topic which distributed this message
  final String? topic;

  /// id of the user who published the message; could be missing if the message was generated by the server
  final String? from;

  /// set of string key-value pairs, passed unchanged from {pub}, optional
  Map<String, dynamic>? head; // 1, 2, 3... ->
  // topic A-B -> stored 1 -> 10, outside -> continue inserting

  String? get dbHead {
    return jsonEncode(head);
  }

  set dbHead(String? value) {
    if (value == null) {
      head = null;
    } else {
      head = jsonDecode(value);
    }
  }

  /// Timestamp
  final DateTime? ts;

  /// Server-issued sequential Id
  // @Id(assignable: true)
  int? seq;

  /// object, application-defined content exactly as published by the user in the {pub} message
  dynamic? content;

  String? get dbContent {
    return jsonEncode(content);
  }

  set dbContent(String? value) {
    if (value == null) {
      content = null;
    } else {
      content = jsonDecode(value);
    }
  }

  bool? noForwarding = false;

  int? hi;

  // ToDo: workaround with a flag to force update new message list after reacting msg
  int mark = 0;

  DataMessage({
    this.id = 0,
    this.topic,
    this.from,
    this.head,
    this.ts,
    this.seq,
    this.content,
    this.noForwarding,
    this.hi,
    this.combinedId
  });

  void setHead(Map<String, dynamic> data) {
    head = data;
  }

  DataMessageType getType() {
    final headData = head;
    if (headData != null) {
      if (headData.containsKey('type')) {
        final type = headData['type'];
        return DataMessageTypeExtension.from(type);
      }
      return DataMessageType.text;
    }
    return DataMessageType.text;
  }

  Map<String, dynamic>? getExtendData() {
    if (getType() != DataMessageType.text) {
      return head?['data'];
    }
    return null;
  }

  static Map<String, dynamic> generateHead(String type, dynamic data,
      {String? senderName, required String roomId}) {
    return senderName != null
        ? {
      'data': data,
      'type': type,
      'room_id': roomId,
      'sender_name': senderName
    }
        : {
      'data': data,
      'type': type,
      'room_id': roomId,
    };
  }

  static DataMessage fromMessage(Map<String, dynamic> msg) {
    return DataMessage(
      topic: msg['topic'],
      from: msg['from'] ?? msg['replyMessage'],
      head: msg['head'],
      ts: msg['ts'],
      seq: msg['seq'],
      content: msg['content'],
      noForwarding: msg['noForwarding'] ?? false,
      hi: msg['hi'],
      combinedId: '${msg['topic']}_${msg['seq']}'
    );
  }

  @override
  List<Object?> get props =>
      [topic, from, head, ts, seq, content, noForwarding, hi, mark];
}